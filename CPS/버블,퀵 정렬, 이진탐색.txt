#pragma warning(disable:4996)
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define DATASIZE1 50000
#define DATASIZE2 100000
#define SWAP(x, y, temp) ( (temp)=(x), (x)=(y), (y)=(temp) )
void BubbleSort(int array[], int n);
void QuickSort(int array[], int low, int high);
int partition(int array[], int left, int right);
int SeqSearch(int array[], int key);
int BinSearch(int array[], int size, int key);

int main() {
    time_t startTime, endTime;
    int numsTobeSorted1[DATASIZE1];
    int numsTobeSorted2[DATASIZE2];
    double result; //걸리는 시간 저장
    int key; //탐색하고자 하는 수 
    int avrTime[10];
    double sum=0, avg;
    
    startTime = time(NULL); //수행시간 측정 시작
    //5만개의 정수를 랜덤 함수를 사용하여 numsTobeSorted 배열에 저장
    for (int i = 0; i < DATASIZE1; i++) {
        numsTobeSorted1[i] = rand() % DATASIZE1 + 1;
    }
    //bubble sort
    BubbleSort(numsTobeSorted1, DATASIZE1);
    endTime = time(NULL); // 수행시간 측정 끝 
    result = (double)(endTime - startTime);
    printf("[5만개] 버블정렬 걸린시간: %f초\n", result);

    startTime = time(NULL); //수행시간 측정 시작
    //10만개의 정수를 랜덤 함수를 사용하여 numsTobeSorted 배열에 저장
    for (int i = 0; i < DATASIZE2; i++) {
        numsTobeSorted2[i] = rand() % DATASIZE2 + 1;
    }
    BubbleSort(numsTobeSorted2, DATASIZE2);
    endTime = time(NULL); // 수행시간 측정 끝 
    result = (double)(endTime - startTime);
    printf("[10만개] 버블정렬 걸린시간: %f초\n", result);
    printf("------------------------------------------------\n");

    startTime = time(NULL); //수행시간 측정 시작
    QuickSort(numsTobeSorted1, 0, DATASIZE1 - 1);
    endTime = time(NULL); // 수행시간 측정 끝 
    result = (double)(endTime - startTime);
    printf("[5만개] 퀵정렬 걸린시간: %f초\n", result);

    startTime = time(NULL); //수행시간 측정 시작
    QuickSort(numsTobeSorted2, 0, DATASIZE2 - 1);
    endTime = time(NULL); // 수행시간 측정 끝 
    result = (double)(endTime - startTime);
    printf("[10만개] 퀵정렬 걸린시간: %f초\n", result);
    printf("------------------------------------------------\n");

    printf("탐색하고자 하는 값(key)를 입력하세요: ");
    scanf("%d", &key);
    printf("순차탐색을 시작합니다.\n\n");
    startTime = time(NULL); //수행시간 측정 시작
    SeqSearch(numsTobeSorted2, key);
    endTime = time(NULL); // 수행시간 측정 끝 
    result = (double)(endTime - startTime);
    printf("순차탐색 걸린시간: %f초\n\n", result);

    QuickSort(numsTobeSorted2, 0, DATASIZE2 - 1);
    printf("이진탐색을 시작합니다.\n");
    startTime = time(NULL); //수행시간 측정 시작
    BinSearch(numsTobeSorted2, DATASIZE2, key);
    endTime = time(NULL); // 수행시간 측정 끝 
    result = (double)(endTime - startTime);
    printf("이진탐색 걸린시간: %f초\n", result);
    printf("------------------------------------------------\n");
    
    for(int i=0; i<10; i++){
         for (int j = 0; j < DATASIZE2; j++) {
            numsTobeSorted2[j] = rand() % DATASIZE2 + 1;
         }
      for(int k=0; k<10; k++){
        avrTime[k]=BinSearch(numsTobeSorted2, DATASIZE2, key);
      }
   }
   
   for(int i=0; i<10; i++){
      sum+=avrTime[i];
   }
   avg=sum/10;
   printf("실행시간 평균:%f", avg);
return 0;
}

// 버블 정렬
void BubbleSort(int array[], int n) {
    int i, j, temp;
    for (i = n - 1; i > 0; i--) {
        // 0 ~ (i-1)까지 반복
        for (j = 0; j < i; j++) {
            // j번째와 j+1번째의 요소가 크기 순이 아니면 교환
            if (array[j] < array[j + 1]) {
                temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
}

//퀵 정렬
// 1. 피벗을 기준으로 2개의 부분 리스트로 나눈다.
// 2. 피벗보다 작은 값은 모두 왼쪽 부분 리스트로, 큰 값은 오른쪽 부분 리스트로 옮긴다.
/* 2개의 비균등 배열 array[low...pivot-1]와 array[pivot+1...high]의 합병 과정 */
/* (실제로 숫자들이 정렬되는 과정) */
int partition(int array[], int low, int high) {
    int pivot, temp;
    int l, h;

    l = low;
    h = high + 1;
    pivot = array[low]; // 정렬할 배열의 가장 왼쪽 데이터를 피벗으로 선택(임의의 값을 피벗으로 선택)

    /* l와 h가 교차할 때까지 반복(l<h) */
    do {
        /* array[l]가 피벗보다 작으면 계속 l을 증가 */
        do {
            l++; // l는 low+1 에서 시작
        } while (l <= high && array[l] < pivot);

        /* array[h]가 피벗보다 크면 계속 h를 감소 */
        do {
            h--; //h는 r 에서 시작
        } while (h >= low && array[h] > pivot);

        // 만약 l와 h가 교차하지 않았으면 array[l]를 array[h] 교환
        if (l < h) {
            SWAP(array[l], array[h], temp);
        }
    } while (l < h);

    // l와 h가 교차했으면 반복문을 빠져나와 array[low]와 list[h]를 교환
    SWAP(array[low], array[h], temp);

    // 피벗의 위치인 h를 반환
    return h;
}

// 퀵 정렬
void QuickSort(int array[], int low, int high) {
    /* 정렬할 범위가 2개 이상의 데이터이면(리스트의 크기가 0이나 1이 아니면) */
    if (low < high) {
        // partition 함수를 호출하여 피벗을 기준으로 리스트를 비균등 분할 -분할(Divide)
        int q = partition(array, low, high); // q: 피벗의 위치

        // 피벗은 제외한 2개의 부분 리스트를 대상으로 순환 호출
        QuickSort(array, low, q - 1); // (l ~ 피벗 바로 앞) 앞쪽 부분 리스트 정렬 -정복(Conquer)
        QuickSort(array, q + 1, high); // (피벗 바로 뒤 ~ h) 뒤쪽 부분 리스트 정렬 -정복(Conquer)
    }
}

int SeqSearch(int array[], int key) {
    for (int i = 0; i < DATASIZE2; i++) {
        if (array[i] == key) {
            return i;
        }
    }
    return -1;
}

int BinSearch(int array[], int size, int key) {
    int first = 0;
    int last = size - 1;
    int mid;
    while (first <= last) {
        mid = (first + last) / 2;
        if(key == array[mid]){
            return mid;
        }else{
            if (key < array[mid]) last = mid - 1;
            else first = mid + 1;
        }
        return -1;
    }
}